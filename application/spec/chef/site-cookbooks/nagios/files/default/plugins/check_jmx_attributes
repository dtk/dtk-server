#!/usr/bin/env ruby
require 'optparse'
options = {:warning=>String.new,:critical=>String.new}

begin
  OptionParser.new do |opts|
    opts.banner = "Usage: check_jmx_attributes [options]"
    opts.on('-F', '--file ATTRIBUTE_FILE', "The file that has the attributes to return")  do |o|
      options[:attribute_file] = o if o
    end
    opts.on('-O', '--object OBJECT', "The object to read")  do |o|
      options[:object] = o if o
    end
    opts.on('-A', '--attribute ATTRIBUTE', "The attribute to read")  do |o|
      options[:attribute] = o if o
    end
    opts.on('-p', '--port Port', /[0-9]+/,"The port to use to communicate with the jvm")  do |o|
      options[:port] = o if o
    end
    opts.on('-P', '--password PASSWORD',"The password to use to communicate with the jvm")  do |o|
      options[:password] = o if o
    end
    opts.on('-W', '--warning Warning',"Condition to consider as a warning")  do |o|
      options[:warning] = o if o
    end
    opts.on('-C', '--critical Critical',"Condition to consider as being critical")  do |o|
      options[:critical] = o if o
    end
  end.parse!

 rescue  => e
  print puts e
  exit 2
end
unless options[:attribute_file] or (options[:object] and options[:attribute])
  $stderr.puts "Error: you must specify an attribute file or specidy a specfic object and attribute"
  exit 2
end
unless options[:port]
  $stderr.puts "Error: you must specify the port"
  exit 2
end
unless options[:password]
  $stderr.puts "Error: you must specify the password"
  exit 2
end

def ret_attributes(options)
  if options[:object] and options[:attribute]
    return [{:object => options[:object], 
             :attribute => options[:attribute],
              :warning => options[:warning],
              :critical => options[:critical]
            }]
  end

  #read and parse the attribute file  
  attr_file_path = File.expand_path("jmx_attributes_files/#{options[:attribute_file]}", File.dirname(__FILE__))

  ret = Array.new
  File.open(attr_file_path) do |f| 
    while line = f.gets  
      if line =~/\|(.+)\|(.+)\|(.+)\|(.+)\|/
        object = $1.strip
        attribute_info = $2.strip
        warning = $3.strip
        critical = $4.strip
        attribute,attribute_key = attribute_info.split(".")
        ret << {
          :object => object,
          :attribute => attribute,
          :attribute_key => attribute_key,
          :warning => warning,
          :critical => critical
        } 
      end
    end  
  end
  ret
end

def execute(options)
  values = Array.new
  highest_status = 0
  port = options[:port]
  password = options[:password]
  ret_attributes(options).each do |attr|
    args = "-U service:jmx:rmi:///jndi/rmi://localhost:#{port.to_s}/jmxrmi -O #{attr[:object]} -A #{attr[:attribute]} -username monitorRole -password #{password}"
    args << " -K #{attr[:attribute_key]}" if attr[:attribute_key]
    command = "/usr/bin/java  -cp #{File.dirname(__FILE__)}/jmxquery.jar jmxquery.JMXQuery"

    results = `#{command} #{args}`.chomp
    status = $?.exitstatus
    highest_status = status if status > highest_status
    #TBD: should modify jar to give back more parsable form"
    if status ==  0 and results =~ /JMX OK - (.+) is (.+)$/
      value = to_num($2)
      thresh_violation = ret_thresh_violation(value,attr[:warning],attr[:critical])
      highest_status = thresh_violation if thresh_violation > highest_status
      name = attr[:attribute] + ( attr[:attribute_key] ? ".#{attr[:attribute_key]}" : "")
      values << {:name => name,:value => value, :thresh => thresh_violation}
    end  
  end
  ret_nagios_results(highest_status,values)
end

def ret_thresh_violation(value,warning,critical)
  unless critical.empty?
    return 2 if violation_holds?(value,critical)
  end
  unless warning.empty?
    return 1 if violation_holds?(value,warning)
  end
  0
end

def violation_holds?(value,cond)
  if cond =~ /([<>])([0-9.]+)/
    comparison = $1
    bound = to_num($2)
    return true if comparison == "<" and value < bound
    return true if comparison == ">" and value > bound
  end
  nil
end

def to_num(x)
  return x.to_i if x =~/[0-9]/
  x.to_f
end

def ret_nagios_results(highest_status,values)
  ret = case highest_status
        when 0
          "JMX OK"
        when 1
          "JMX WARNING"
        when 2
          "JMX CRITICAL"
        end
  violations = values.reject{|x| x[:thresh] == 0}.map do |y|
    "#{y[:name]}: #{y[:value]}"
  end.join(", ")
  ret << (" " + violations) unless violations.empty?

  good_vals =  values.reject{|x| x[:thresh] > 0}.map do |y|
    "#{y[:name]}: #{y[:value]}"
  end.join(" | ")
  ret << (" | " + good_vals) unless good_vals.empty?

  puts ret
  exit highest_status
end

execute(options)



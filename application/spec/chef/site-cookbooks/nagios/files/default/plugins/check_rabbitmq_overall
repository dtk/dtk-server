#!/usr/bin/env ruby
#adapted from
# Created by Doug Barth. 
# http://github.com/dougbarth/
require 'optparse'

options = {:rabbitmqctl => 'sudo /usr/sbin/rabbitmqctl'}

optparser = OptionParser.new do |opt|
  opt.banner = "Usage: #{$0}"
end

args = []
begin
  args = optparser.parse!
rescue => e
  $stderr.print e
  $stderr.print optparser
  exit 0
end

class RabbitmqOverall 
  def initialize(options={})
    @options = options
    @vhosts = nil
  end

  def run()
    stats = get_stats()
    attributes = get_attributes()
    ret_results(stats,attributes)
  end

  def get_stats()
    begin
      report_data = {}

      connection_stats = `#{rabbitmqctl} -q list_connections`.to_a
      report_data['connections'] = connection_stats.size

      report_data['queues'] = report_data['messages'] = report_data['queue_mem'] = 0
      report_data['exchanges'] = 0
      report_data['bindings'] = 0
      vhosts.each do |vhost|
        queue_stats = `#{rabbitmqctl} -q list_queues -p '#{vhost}' messages memory`.to_a
        report_data['queues'] += queue_stats.size
        report_data['messages'] += queue_stats.inject(0) do |sum, line|
          sum += line.split[0].to_i
        end

        report_data['queue_mem'] += queue_stats.inject(0) do |sum, line|
          sum += line.split[1].to_i
        end

        exchange_stats = `#{rabbitmqctl} -q list_exchanges -p #{vhost}`.to_a
        report_data['exchanges'] += exchange_stats.size

        binding_stats = `#{rabbitmqctl} -q list_bindings -p #{vhost}`.to_a
        report_data['bindings'] += binding_stats.size
      end

      # Convert queue memory from bytes to MB.
      report_data['queue_mem'] = report_data['queue_mem'].to_f / (1024 * 1024)

      report_data
    rescue RuntimeError => e
      print "CRITICAL - #{e}"
      exit 2
    end
  end

  ###### attribute file processing; TBD: shared (cut and paste now) with otehr checks so shoudl be gem or common library
  def get_attributes()
    #read and parse the attribute file  
    attr_file_path = "/usr/lib/nagios/plugins/rabbitmq/attributes.data"
    ret = Array.new
    File.open(attr_file_path) do |f|
      while line = f.gets
        if line =~/\|(.+)\|(.+)\|(.+)\|(.+)\|/
          object = $1.strip
          attribute_info = $2.strip
          warning = $3.strip
          critical = $4.strip
          attribute,attribute_key = attribute_info.split(".")
          ret << {
            :object => object,
            :attribute => attribute,
            :attribute_key => attribute_key,
            :warning => warning,
            :critical => critical
          }
        end
      end
    end
    ret
  end
  def ret_results(stats,attributes)
    highest_status = 0
    annotated_values = Array.new
    attributes.each do |attr|
      value = attr[:attribute] ? stats[attr[:attribute]] : nil
      next unless value
      thresh_violation = ret_thresh_violation(value,attr[:warning],attr[:critical])
      highest_status = thresh_violation if thresh_violation > highest_status
      name = attr[:attribute] 
      annotated_values << {:name => name,:value => value, :thresh => thresh_violation}
    end
    ret_nagios_results(highest_status,annotated_values)
  end

  def ret_thresh_violation(value,warning,critical)
    unless critical.empty?
      return 2 if violation_holds?(value,critical)
    end
    unless warning.empty?
      return 1 if violation_holds?(value,warning)
    end
    0
  end

  def violation_holds?(value,cond)
    if cond =~ /([<>])([0-9.]+)/
      comparison = $1
      bound = to_num($2)
      return true if comparison == "<" and value < bound
      return true if comparison == ">" and value > bound
    end
    nil
  end

  def to_num(x)
    return x.to_i if x =~/[0-9]/
    x.to_f
  end

  def ret_nagios_results(highest_status,values)
    ret = case highest_status
          when 0
            "JMX OK"
          when 1
            "JMX WARNING"
          when 2
            "JMX CRITICAL"
          end
    violations = values.reject{|x| x[:thresh] == 0}.map do |y|
      "#{y[:name]}: #{y[:value]}"
    end.join(", ")
    ret << (" " + violations) unless violations.empty?

    good_vals =  values.reject{|x| x[:thresh] > 0}.map do |y|
      "#{y[:name]}: #{y[:value]}"
    end.join(" | ")
    ret << (" | " + good_vals) unless good_vals.empty?

    puts ret
    exit highest_status
  end

  ###### end of attribute parsing processing
  def rabbitmqctl
    @options[:rabbitmqctl]
  end

  def vhosts
    @vhosts ||= `#{rabbitmqctl} -q list_vhosts`.to_a
  end

  def `(command)
    result = super(command)
    status = $?.exitstatus
    if (status != 0)
      msg = if (status == 2)
              "service is down"
            else
              "exit status = #{status}"
            end
      print "CRITICAL - #{msg}"
      exit 2
    end
    result
  end
end

RabbitmqOverall.new(options).run
